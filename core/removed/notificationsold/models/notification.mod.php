<?

//--------------------------------------------------------------------------------------------------
//*	object for managing user notifications
//--------------------------------------------------------------------------------------------------
//+	All users have a notification queue. Notifications are equivalent to events on a facebook, when
//+	something happens a notification is generated and added to the queue of all relevant parties, 
//+	say an image is uploaded by a user, that users friends recieve a notification, if a club makes
//+	an announcement, club members recieve a notification, if the school makes an announcement, 
//+	everyone gets a notification.  Notifications are generated by other modules and pushed to 
//+	users queues as an xml snippet.	 By default the notice queue is 100 items long.
//+
//+	Notifications are identified by a UID, which may differ slightly in form from record UIDS
//+	but must still be unique.  This UID is to prevent the same notice from appearing multiple times
//+	in a queue, say if a notice was sent to a users soccer team, friends and class, all of which
//+	may overlap.
//+
//+	Notifications are added by special core functions:
//+
//+	notifyUser('userUID', 'noticeUID', 'from', 'fromurl', 'title', 'content', 'url')
//+	notifySchool('schoolUID', 'noticeUID', 'from', 'fromurl', 'title', 'content', 'url');
//+	notifyGroup('groupUID', 'noticeUID', 'from', 'fromurl', 'title', 'content', 'url');
//+	etc...
//
//+	Notices have the form:
//+	 <notification>
//+	  <user>231095871</user>
//+	  <UID>231095871</UID>
//+	  <from>James Joyce (chess club)</from>
//+	  <fromurl>http://www.awarenet.co.za/users/JamesJoyce</fromurl>
//+	  <title>Match against St Marys High</title>
//+	  <content>Tomorrow we will be travelling....</content>
//+	  <url>http://www.awarenet.co.za/groups/ChessClub#announcement56345634</url>
//+	  <imgUID>34252443</imgUID>
//+	  <timestamp>23423409</timestamp>
//+  </notification>
//+
//+	TODO: replace imgUID with a block (image might be gone by the time user sees the notice)
//+	TODO: make notices first class objects, longer term, perhaps retain this as a precache?

class NotificationQueue {

	//----------------------------------------------------------------------------------------------
	//	member variables (as retieved from database)
	//----------------------------------------------------------------------------------------------

	var $data;				// currently loaded record [array]
	var $dbSchema;			// database structure
	var $notifications;		// array of notifications, ordered by timestamp

	var $noticeFields = 'user|UID|from|fromurl|title|content|url|imgUID|timestamp';

	//----------------------------------------------------------------------------------------------
	//.	constructor
	//----------------------------------------------------------------------------------------------
	//opt: userUID - UID of a user [string]

	function NotificationQueue($userUID = '') {
		global $db;

		$this->dbSchema = $this->getDbSchema();
		$this->data = $db->makeBlank($this->dbSchema);
		$this->notifications = array();
		if ($userUID != '') { $this->load($userUID); }
	}

	//----------------------------------------------------------------------------------------------
	//.	load a notification queue by userUID, or create a notification queue if one does not exist
	//----------------------------------------------------------------------------------------------
	//arg: userUID - UID of a user [string]
	//returns: true on success, false on failure [bool]

	function load($userUID) {
		global $kapenta, $db;

		if ($db->objectExists('users', $userUID) == false) { return false; }
		$sql = "select * from notices where user='" . $db->addMarkup($userUID) . "'";
		$result = $db->query($sql);
		
		if (0 == $db->numRows($result)) {
			$this->UID = $kapenta->createUID();
			$this->user = $userUID;
			$this->notices = '';
			$this->save();
		} else {
			$this->data = $db->rmArray($db->fetchAssoc($result));
			$this->expandNotifications();
		}
		return true;
	}

	//----------------------------------------------------------------------------------------------
	//.	load a record provided as an associative array
	//----------------------------------------------------------------------------------------------
	//arg: ary - associative array of fields and values [array]

	function loadArray($ary) { $this->data = $ary; }

	//----------------------------------------------------------------------------------------------
	//.	save a record
	//----------------------------------------------------------------------------------------------

	function save() {
	global $db;

		$verify = $this->verify();
		if ($verify != '') { return $verify; }
		$this->collapseNotifications();
		$db->save($this->data, $this->dbSchema); 
	}

	//----------------------------------------------------------------------------------------------
	//.	verify - check that a record is correct before allowing it to be stored in the database
	//----------------------------------------------------------------------------------------------
	//,	nothing to check as yet

	function verify() { return ''; }

	//----------------------------------------------------------------------------------------------
	//.	sql information
	//----------------------------------------------------------------------------------------------
	//returns: database table layout [array]

	function initDbSchema() {
		$dbSchema = array();
		$dbSchema['table'] = 'notices';
		$dbSchema['fields'] = array(
			'UID' => 'VARCHAR(30)',	
			'user' => 'VARCHAR(30)',	
			'notices' => 'TEXT',
			'editedOn' => 'DATETIME',
			'editedBy' => 'VARCHAR(30)' );

		$dbSchema['indices'] = array('UID' => '10', 'user' => '20');
		$dbSchema['nodiff'] = array('UID', 'notices');
		return $dbSchema;
	}

	//----------------------------------------------------------------------------------------------
	//.	serialize this object to an array
	//----------------------------------------------------------------------------------------------
	//returns: associative array of all variables which define this instance [array]

	function toArray() { return $this->data; }

	//----------------------------------------------------------------------------------------------
	//.	make array of notifications, ordered by time
	//----------------------------------------------------------------------------------------------
	//, unused as yet

	function extArray() {
		// TODO, unused as yet
	}

	//----------------------------------------------------------------------------------------------
	//.	install this module
	//----------------------------------------------------------------------------------------------
	//returns: html report lines [string]
	//, deprecated, this should be handled by ../inc/install.inc.inc.php

	function install() {
	global $db;

		$report = "<h3>Installing Notices Module</h3>\n";

		//------------------------------------------------------------------------------------------
		//	create notices table if it does not exist
		//------------------------------------------------------------------------------------------

		if ($db->tableExists('notices') == false) {	
			echo "installing notices module\n";
			dbCreateTable($this->dbSchema);	
			$this->report .= 'created notices table and indices...<br/>';
		} else {
			$this->report .= 'notices table already exists...<br/>';	
		}

		return $report;
	}
	
	//----------------------------------------------------------------------------------------------
	//.	delete the current record
	//----------------------------------------------------------------------------------------------

	function delete() {
	global $db;
	$db->delete('notices', $this->UID); }

	//----------------------------------------------------------------------------------------------
	//.	expand notifications (from XML into array)
	//----------------------------------------------------------------------------------------------

	function expandNotifications() {
		$this->notifications = array();
		$nF = explode('|', $this->noticeFields);
		$xe = new XmlEntity($this->notices);
		foreach($xe->children as $index => $notice) {
			$newNotice = array();
			foreach($nF as $field) 
				{ $newNotice[$field] = base64_decode($notice->getFirst($field)); }
			$this->notifications[$newNotice['UID']] = $newNotice;
		}
	}

	//----------------------------------------------------------------------------------------------
	//.	collapse notifications
	//----------------------------------------------------------------------------------------------

	function collapseNotifications() {
		$nF = explode('|', $this->noticeFields);
		$xml = "<notificationqueue>\n";
		foreach($this->notifications as $notice) {
			$xml .= "\t<notification>\n";
			foreach($nF as $fd) 
				{ $xml .= "\t\t<" . $fd . ">" . base64_encode($notice[$fd]) . "</" . $fd . ">\n"; }

			$xml .= "\t</notification>\n";
		}
		$xml .= "</notificationqueue>\n";
		$this->notices = $xml;	
	}

	//----------------------------------------------------------------------------------------------
	//.	add a notification, if it is not already in queue
	//----------------------------------------------------------------------------------------------
	//arg: noticeUID - UID of a notification [string]
	//arg: from - source of this notification, html [string]
	//arg: fromurl - url of item which caused this notification [string]
	//arg: title - notice title [string]
	//arg: content - body of notice, html [string]
	//arg: url - url of item to which notice refers [string]
	//arg: imgUID - UID of an image [string]
	//returns: true of success, false on failure

	function addNotification($noticeUID, $from, $fromurl, $title, $content, $url, $imgUID) {
		if (array_key_exists($noticeUID, $this->notifications) == true) { return false; }
		$newNotice = array();
		$newNotice['user'] = $this->user;
		$newNotice['UID'] = $noticeUID;
		$newNotice['from'] = $from;
		$newNotice['fromurl'] = $fromurl;
		$newNotice['title'] = $title;
		$newNotice['content'] = $content;
		$newNotice['url'] = $url;
		$newNotice['imgUID'] = $imgUID;
		$newNotice['timestamp'] = time();
		$this->notifications[$newNotice['UID']] = $newNotice;
		$this->sort();
		$this->save();
		return true;
	}

	//----------------------------------------------------------------------------------------------
	//.	sort notifications by timestamp
	//----------------------------------------------------------------------------------------------

	function sort() {
		$twoD = array();
		$notifications = $this->notifications;
		foreach($notifications as $key => $notice) { 
					$twoD[$key] = $notice['timestamp']; 
		}
		asort($twoD);
		$this->notifications = array();
		foreach($twoD as $key => $timestamp) {
			$this->notifications[$key] = $notifications[$key];
		}
	}

}

?>
